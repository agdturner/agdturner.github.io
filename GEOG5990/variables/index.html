<!DOCTYPE html>
<html lang=en-GB>
<head>
<title>Variables Page</title>
<!-- Styling. -->
<!-- The following href is blank, but will be populated once the
DOM is fully loaded. -->
<link id="css" rel="stylesheet" type="text/css" href=""><script src="/scripts/style.js"></script>
<!-- The following are used for stying code. -->
<script src="/tools/highlight/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
<link id="code_theme" rel="stylesheet" type="text/css" href="">
<!-- Styling. -->
<script src="/scripts/style.js"></script>
<!-- The following are used for stying code. -->
<script src="/tools/highlight/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
<!-- The following href should be set when the DOM is loaded. -->
<link id="css1" rel="stylesheet" type="text/css" href="">
<link id="css2" rel="stylesheet" type="text/css" href="">
</head>
<body>
<header>
<button id="style_button" onclick="swapStyle()"></button>
<div>
<nav>
<a id="home" class="nav" href="../home/index.html">Home</a> <a id="programming" class="nav" href="../programming/index.html">Programming</a> <a id="python" class="nav" href="../python/index.html">Python</a> <a id="variables" class="nav" href="../variables/index.html">Variables</a> <a id="github" class="nav" href="../github/index.html">GitHub</a> <a id="abm1" class="nav" href="../abm1/index.html">ABM1</a> <a id="containers" class="nav" href="../containers/index.html">Containers</a> <a id="branching" class="nav" href="../branching/index.html">Branching</a> <a id="loops" class="nav" href="../loops/index.html">Loops</a> <a id="abm2" class="nav" href="../abm2/index.html">ABM2</a> <a id="functions" class="nav" href="../functions/index.html">Functions</a> <a id="abm3" class="nav" href="../abm3/index.html">ABM3</a> <a id="classes" class="nav" href="../classes/index.html">Classes</a> <a id="abm4" class="nav" href="../abm4/index.html">ABM4</a> <a id="io" class="nav" href="../io/index.html">IO</a> <a id="abm5" class="nav" href="../abm5/index.html">ABM5</a> <a id="modules" class="nav" href="../modules/index.html">Modules</a> <a id="abm6" class="nav" href="../abm6/index.html">ABM6</a> <a id="exceptions" class="nav" href="../exceptions/index.html">Exceptions</a> <a id="abm7" class="nav" href="../abm7/index.html">ABM7</a> <a id="gui" class="nav" href="../gui/index.html">GUI</a> <a id="abm8" class="nav" href="../abm8/index.html">ABM8</a> <a id="web" class="nav" href="../web/index.html">Web</a> <a id="abm9" class="nav" href="../abm9/index.html">ABM9</a> <a id="assignments" class="nav" href="../assignments/index.html">Assignments</a> <a id="index" class="nav" href="../index/index.html">Index</a> <a id="references" class="nav" href="../references/index.html">References</a>
</nav>
</div>
</header>
<div>
<h1>Variables</h1>
<h2>1. Introduction</h2>
<p>Python variables are a combination of an identifying label or
name and a value - either a primitive or a more complex object
(which may comprise a single primitive variable or be comprised of
multiple other primitive variables and other objects).</p>
<p>Variables work a bit differently depending on whether they are
primitives or objects. The main difference is to do with whether
the variable is duplicated when it is passed into a function as a
parameter or whether a reference or pointer is passed in which
still refers to the value of the variable. There are other
differences to do with scope, but let's not worry about this for
now, we will revise all this in due course...</p>

<h2>2. Variables Types</h2>
In Python, variable labels/names can be reused to refer to
different types of value. This is known as dynamic typing. It
allows us to initialise a variable with an Integer value and then
set it later to have a value given by a Float or a String or
something non-primitive like a List. The Type Function (type()) in
the Built In Module
(<a href="https://docs.python.org/3/library/builtins.html">builtins</a>)
allows for testing the type of a variable at some stage of a
program execution. For example, the following code initialises a
variable called x to have the Integer value 1, then sets it
again to have the String value "1", after each assignment the type
of the variable is printed.</p>
<pre><code class="language-python"># Set x = 1 and print the type of x")
x = 1
print(type(x))
x = "1"
print(type(x))</code></pre>
<p>The output from running this code is:</p>
<pre>&lt;class 'int'&gt;
&lt;class 'str'&gt;</pre>
<p>Again, try this yourself.</p>
<p>In declarative programming languages, the type of a variable
is declared. If the langauge is statically typed, then the
variable is not permitted to change type. Some of the most
commonly used high level languages (including
<a href="https://en.wikipedia.org/wiki/Java_(programming_language)">Java</a>) are both
declarative and statically typed.</p>
<p>The type of Python variables do not have to be declared, and
labels can be reassigned to different types of thing. There are
both benefits and drawbacks of this. Code can look a bit more
succinct, interfaces can be more stable, and some developers find
it easier to experiment this way, but there are dangers and
some things are much harder with dynamically typed langauges, for
example writing tools for developing code. It is possible though,
as we have seen, to test the type of a variable, so type safety
checks can be added to code. However, this makes code more verbose
and less efficient.
<p>

<h3>2.1. Primitives</h3>
<p>The four primitive variable types in Python are: Integers,
Floats, Strings, and Booleans. Integers are whole numbers. Floats
are a special subset of fractions. We've looked at these briefly
before. Strings are essentially blocks of text. We created some of
these too already. Booleans are True or False and also equate to 0
or 1.</p>
<p>Integers are virtually unbounded in Python although there is
ultimately a limit based on the size of a word that Python and the
machine can handle (which is typically very large, but depends on
available memory).</p>
<p>Floats have a Maximum Value and a Minimum Normal Value
(smallest number > 0). These can be ascertained from the Sys
Module (sys) and can also be set to postive or negative
infinity:</a>
<pre><code class="language-python">import sys

# Exploring Float max and min values.
max = sys.float_info.max
min = sys.float_info.min
print("max", max)
print("min", min)

# Are there any changes?
print("max + min", max + min)
print("max - min", max - min)
print("min + min", min + min)

# What number do we need to add to max to get inf?
max2 = max
d = 2
while max2 == max:
    max2 = max2 + d
    d *= 2
d = d / 2
print("d", d)
print("max + d/2", max + d/2)
print("max + d", max + d)

# Find a number bigger than min which is the same when min is
# added to it.
min2 = min * 10**16
min3 = min2 + min
if min3 > min2:
    print("min3 > min2")
print("min2", min2)</code></pre>
<p>This code generates the following output:</p>
<pre>
max 1.7976931348623157e+308
min 2.2250738585072014e-308
max + min 1.7976931348623157e+308
max - min 1.7976931348623157e+308
min + min 4.450147717014403e-308
d 9.9792015476736e+291
max + d/2 1.7976931348623157e+308
max + d inf
min2 2.2250754194454158e-293</pre>
<p>Float is extremely useful, but programmers must bear in mind
the approximate nature of calculations with these numbers. In
geographical contexts care is especially needed when computing
geometrical intersections.</p>
<p><a href="https://docs.python.org/3/library/decimal.html#floating-point-notes">
Python documentation floating point notes</a></p>
<p>Python supports other types of number which you may find
useful:</p>
<ul>
<li><a href="https://docs.python.org/3/library/decimal.html">decimal</a></li>
<li><a href="https://docs.python.org/3/library/fractions.html">fractions</a></li>
</ul>
<p>Strings can be assigned using; double or single quotes, and the
str() constructor function (which can for example create a String
from an Integer. Strings can be compared and checked for equality.
Consider the following code:</p>
<pre><code class="language-python">s = "A"
s2 = "a"
s3 = "B"
print(s == s)  # True
print(s == s2) # False (case sensitive)
print(s == s3) # False
print(s > s2)  # False
print(s < s2)  # True
print(str(3))  # 3
</code></pre>
<p>Some code to explore Boolean:</p>
<pre><code class="language-python">t = True
f = False
print("t == t", t == t)             # True
print("f == f", f == f)             # True
print("t == 1", t == 1)             # True
print("f == 0", f == 0)             # True
print("t != f", t != f)             # True
print("not t", not t)               # False
print("not f", not f)               # True
print("t and f", t and f)           # False
print("t and not f", t and not f)   # True
print("t or f", t or f)             # True
print("not (t or f)", not (t or f)) # False</code></pre>

<h3>2.2. Objects</h3>
<p>The following code sets the variable x to be 1 and y to equal
x, it then adds 1 to the value of x and prints out y.</p>
<pre><code class="language-python">
x = 0    # Set x equal to 0
y = x    # Set y equal to x
x = 1    # Set x to a different value
print(y) # 0 (y no longer equals x)
</code></pre>
<p>So, y only has the same value as x until x is assigned another
value.</p>
<p>The following code: creates a list variable called a, sets
b to equal a, appends the Integer 1 to the list a, and then prints
out b.</p>
<pre><code class="language-python">
a = [] # Assign a to equal a new empty List.
b = a  # Set b to equal a
a.append(1) # Append the Integer 1 to the List a
print(b) # [1]
</code></pre>
<p>The output from running this code is:</p>
<pre>[1]</pre>
<p>So, a and b are still referring to the same thing, the same
list. That is because appending to the list does not change the
references to the list, it changes what is in the list.</p>
<p>Try running this code and then modify it to append another
thing to the list and print out a and b to check they are still
the same.</p>
<p>Now, if a is reassigned, then b will still refer to the list
containing the Integer 1 (and whatever else was appended to it).
Have a play around to help this make sense.</p>

<a name="3"/>
<h2>3. Functions, Variable Scope and the Global Keyword</h2>
<p>The scope of a variable is from where in the code it can be
accessed. The Global Keyword (global) can modify the scope.</p>
<p>Run the following program code:</p>
<pre><code class="language-python">x = 1
if x == 1:
    y = 2
print(y)</code></pre>
<p>It should produce the output:</p>
<pre>2</pre>
<p>Now, the program runs one line one at a time, from top to
bottom. If the expression of the IF Statement evaluated as false,
then the interpretter would skip the internal part of it. For
example, the following code:</p>
<pre><code class="language-python">x = 1
if x == 0:
    y = 2
print(y)</code></pre>
<p>Produces the error:</p>
<pre>Traceback (most recent call last):

  File "variables1.py", line 4, in <module>
    print(y)

NameError: name 'y' is not defined</pre>
<p>Have a think about this, then read and run the following code:</p>
<pre><code class="language-python">x = 1
def my_function():
    x = 2
    print("b", x)
print("a", x)
my_function()
print("c", x)</code></pre>
<p>The output should be:</p>
<pre>a 1
b 2
c 1</pre>
<p>At line 2, the interpretter reads a function definition for a
function called my_function(), then skips to the end of the
function and executes line 5. Then at line 6 my_function() is
called. The interpreter then effectively goes back to line 2 and
runs the function (lines 2 to 4). Then, at the end of the
function, the interpretter returns to the next bit of code after
my_function() call i.e. line 7.</p>
<p>Now, the variable inside the function called x is a different
variable to the one outside of the function (even though the names
are the same). Using the global keyword, we can make these
variables the same as follows:</p>
<pre><code class="language-python">x = 1
def my_function():
    global x
    x = 2
    print("b", x)
print("a", x)
my_function()
print("c", x)</code></pre>
<p>The output should be:</p>
<pre>a 1
b 2
c 2</pre>
<p>Try the code yourself and play around to test your
understanding.</p>
<p>Note that after we have defined the function, there is no
function documentation that outlines what it is and what it
does. The function takes in no arguments (parameters) and there is
no return statement. We will learn about functions in more detail
and how to document them a bit later in the course...</p>

<h2>4. Deleting variables</h2>
<p>Variables can be deleted using the Del Function (del()) in the
builtin module.</p>
<p>Variables are usually deleted to free up resources. The
following code snippe shows how to initialise a variable called
and then delete it:<p>
<pre>a = 1
del(a)
print(a) # <-- Results in: NameError: name 'a' is not defined</pre>

</div>
<footer>
<div>
<p><a id="next" class="nav" href="../github/index.html">Next: GitHub</a></p>
</div>
<p>Date last modified: 2023-01-31.</p>
<p><a href="https://creativecommons.org/share-your-work/public-domain/cc0/">CC0 Licence</a></p>
</footer>
</body>
</html>
