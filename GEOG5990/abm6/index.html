<!DOCTYPE html>
<html lang=en-GB>
<head>
<title>Agent Based Model Part 6 Page</title>
<!-- Styling. -->
<!-- The following href is blank, but will be populated once the
DOM is fully loaded. -->
<link id="css" rel="stylesheet" type="text/css" href=""><script src="/scripts/style.js"></script>
<!-- The following are used for stying code. -->
<script src="/tools/highlight/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
<link id="code_theme" rel="stylesheet" type="text/css" href="">
<!-- Styling. -->
<script src="/scripts/style.js"></script>
<!-- The following are used for stying code. -->
<script src="/tools/highlight/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
<!-- The following href should be set when the DOM is loaded. -->
<link id="css1" rel="stylesheet" type="text/css" href="">
<link id="css2" rel="stylesheet" type="text/css" href="">
</head>
<body>
<header>
<button id="style_button" onclick="swapStyle()"></button>
<div>
<nav>
<a id="home" class="nav" href="../home/index.html">Home</a> <a id="programming" class="nav" href="../programming/index.html">Programming</a> <a id="python" class="nav" href="../python/index.html">Python</a> <a id="variables" class="nav" href="../variables/index.html">Variables</a> <a id="github" class="nav" href="../github/index.html">GitHub</a> <a id="abm1" class="nav" href="../abm1/index.html">ABM1</a> <a id="containers" class="nav" href="../containers/index.html">Containers</a> <a id="branching" class="nav" href="../branching/index.html">Branching</a> <a id="loops" class="nav" href="../loops/index.html">Loops</a> <a id="abm2" class="nav" href="../abm2/index.html">ABM2</a> <a id="functions" class="nav" href="../functions/index.html">Functions</a> <a id="abm3" class="nav" href="../abm3/index.html">ABM3</a> <a id="classes" class="nav" href="../classes/index.html">Classes</a> <a id="abm4" class="nav" href="../abm4/index.html">ABM4</a> <a id="io" class="nav" href="../io/index.html">IO</a> <a id="abm5" class="nav" href="../abm5/index.html">ABM5</a> <a id="modules" class="nav" href="../modules/index.html">Modules</a> <a id="abm6" class="nav" href="../abm6/index.html">ABM6</a> <a id="exceptions" class="nav" href="../exceptions/index.html">Exceptions</a> <a id="abm7" class="nav" href="../abm7/index.html">ABM7</a> <a id="gui" class="nav" href="../gui/index.html">GUI</a> <a id="abm8" class="nav" href="../abm8/index.html">ABM8</a> <a id="web" class="nav" href="../web/index.html">Web</a> <a id="abm9" class="nav" href="../abm9/index.html">ABM9</a> <a id="assignments" class="nav" href="../assignments/index.html">Assignments</a> <a id="index" class="nav" href="../index/index.html">Index</a> <a id="references" class="nav" href="../references/index.html">References</a>
</nav>
</div>
</header>
<div>
<h1>Agent Based Model Part 6</h1>
<h2 id="1">1. Introduction and Preparation</h2>
<p>To get the agents in the model communicating they need a way of
referring to each other, to get values of some variables and to
set values of some variables. Communication will depend on
distance in our simple model, so each agent will need a way to
calculate which other agents are within a given distance of them.
</p>
<p>In your local code repository src directory create a new
directory called "abm6". Open Spyder and use "save as" to save
your "model.py" into this directory. Create a new directory called
"my_modules" in abm6 and use "save as" to save your
"agentframework.py" and "io.py" files there.</p>

<h2 id="2">2. Sharing</h2>
<p>What we are actually going to implement is a sharing mechanism
where each agent shares their store equally amongst all agents
within a given radius. The algorithm is as follows:</p>
<pre># Calculate which other agents are within radius.
# Calculate shares.
# Distribute shares
# Add shares to stores.</pre>
<p>This has to be done in two parts to be done fairly (so the
order in which we do this is irrelevant), and requires an extra
variable.</p>
<p>Change the Agent contructor function to include the
agents list and add an attribute for storing the shares as
follows:</p>
<pre><code class="language-python">def __init__(self, agents, i, environment, nrows, ncols):
        self.agents = agents
        self.store_shares = 0</code></pre>
<p>Change model.py so that agents are initialised passing in the
reference to the agents list.</p>
<p>Test your code works and that this provide access to another
agent by printing out another agent from an agent.</p>
<p>In agentframework.py we are going to want to use the
get_distance function, and we want to avoid cyclic imports. Create
a new file called geometry.py in the my_modules directory, and
move the get_distance method from model.py to it. Add an
import statement for geometry in model.py and change where the
function is called by referring to the new module and by using the
dot operator. (In other words change "get_distance" to
"geometry.get_distance").</p>
<p>Import the geometry module into agentframework and add the
following method:</p>
<pre><code class="language-python">def share(self, neighbourhood):
# Create a list of agents in neighbourhood
neighbours = []
#print(self.agents[self.i])
for a in self.agents:
    distance = geometry.get_distance(a.x, a.y, self.x, self.y)
    if distance < neighbourhood:
        neighbours.append(a.i)
# Calculate amount to share
n_neighbours = len(neighbours)
#print("n_neighbours", n_neighbours)
shares = self.store / n_neighbours
#print("shares", shares)
# Add shares to store_shares
for i in neighbours:
    self.agents[i].store_shares += shares</code></pre>
<p>This code is using the fact that self.i will be the same as the
index of an agent in the agents list. In the first For Loop the
distance between self and each agent in the agents lists
(including itself) is calculated and if this is less than the
neighbourhood paramter that is passed in, then the index of the
agent from the agents list is stored in the neighbours list. The
attribute self.store is than divided into shares and added to the
store_shares attribute of all neighbours.</p>
<p>Replace the model loop in the model.py file with the following:
</p>
<pre><code class="language-python"># Model loop
for ite in range(n_iterations):
    print("Iteration", ite)
    # Move agents
    print("Move")
    for i in range(n_agents):
        agents[i].move(x_min, y_min, x_max, y_max)
        agents[i].eat()
        #print(agents[i])
    # Share store
    # Distribute shares
    for i in range(n_agents):
        agents[i].share(neighbourhood)
    # Add store_shares to store and set store_shares back to zero
    for i in range(n_agents):
        print(agents[i])
        agents[i].store = agents[i].store_shares
        agents[i].store_shares = 0
    print(agents)
    # Print the maximum distance between all the agents
    print("Maximum distance between all the agents", get_max_distance())
    # Print the total amount of resource
    sum_as = sum_agent_stores()
    print("sum_agent_stores", sum_as)
    sum_e = sum_environment()
    print("sum_environment", sum_e)
    print("total resource", (sum_as + sum_e))</code></pre>
<p>Run model.py and try to interpret the output. Add in more print
statements and play around to gain a good understanding of how
the code works.</p>

<h2 id="3">3. Coding Tasks</h2>
<p>Create some more variable results by randomly setting the
store of each agent in initialisation to be a value between 0 and
100.</p>
<p>Change the eat function so that if an agent store reaches 100,
then half the store is released back to the environment.</p>

</div>
<footer>
<div>
<p><a id="next" class="nav" href="../exceptions/index.html">Next: Exceptions</a></p>
</div>
<p>Date last modified: 2023-02-21.</p>
<p><a href="https://creativecommons.org/share-your-work/public-domain/cc0/">CC0 Licence</a></p>
</footer>
</body>
</html>
