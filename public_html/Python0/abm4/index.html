<!DOCTYPE html>
<html lang=en-GB>
<head>
<title>Agent Based Model Practical 4 Page</title>
<!-- Styling. -->
<!-- The following href is blank, but will be populated once the
DOM is fully loaded. -->
<link id="css" rel="stylesheet" type="text/css" href="">
<script src="/scripts/style.js"></script>
<!-- The following are used for styling code. -->
<script src="/tools/highlight/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
<link id="code_theme" rel="stylesheet" type="text/css" href="">

</head>
<body>
<header>
<button id="style_button" onclick="swapStyle()"></button>

<div>
<nav>
<a id="home" class="nav" href="../home/index.html">Home</a> <a id="programming" class="nav" href="../programming/index.html">Programming</a> <a id="python" class="nav" href="../python/index.html">Python</a> <a id="variables" class="nav" href="../variables/index.html">Variables</a> <a id="github" class="nav" href="../github/index.html">GitHub</a> <a id="abm1" class="nav" href="../abm1/index.html">ABM1</a> <a id="containers" class="nav" href="../containers/index.html">Containers</a> <a id="branching" class="nav" href="../branching/index.html">Branching</a> <a id="loops" class="nav" href="../loops/index.html">Loops</a> <a id="abm2" class="nav" href="../abm2/index.html">ABM2</a> <a id="functions" class="nav" href="../functions/index.html">Functions</a> <a id="abm3" class="nav" href="../abm3/index.html">ABM3</a> <a id="classes" class="nav" href="../classes/index.html">Classes</a> <a id="abm4" class="nav" href="../abm4/index.html">ABM4</a> <a id="io" class="nav" href="../io/index.html">IO</a> <a id="abm5" class="nav" href="../abm5/index.html">ABM5</a> <a id="modules" class="nav" href="../modules/index.html">Modules</a> <a id="abm6" class="nav" href="../abm6/index.html">ABM6</a> <a id="exceptions" class="nav" href="../exceptions/index.html">Exceptions</a> <a id="abm7" class="nav" href="../abm7/index.html">ABM7</a> <a id="gui" class="nav" href="../gui/index.html">GUI</a> <a id="abm8" class="nav" href="../abm8/index.html">ABM8</a> <a id="web" class="nav" href="../web/index.html">Web</a> <a id="abm9" class="nav" href="../abm9/index.html">ABM9</a> <a id="testing" class="nav" href="../testing/index.html">Testing</a> <a id="index" class="nav" href="../index/index.html">Index</a> <a id="references" class="nav" href="../references/index.html">References</a>
</nav>
</div>
</header>
<div>
<h1>Agent Based Model Practical 4</h1>
<div>
<h2>Contents</h2>
<ul>
<li><a href="#0">0. Recap and preparation</a><li><a href="#1">1. Define an Agent class</a><li><a href="#2">2. Separation of Concerns</a><li><a href="#3">3. Give each agent a unique name</a></li>
</ul>
</div>

<h2 id="0">0. Recap and preparation</h2>
<P>Currently, 'agents' is a list that contains lists of two items;
an x-coordinate, and a y-coordinate. More items could be added
to the lists to representing additional agent characteristics.
However, the longer the lists become, the harder it is to
remember what is stored in each index and the more confusing
code gets.
</P>
<P>Defining an Agent class provides a way to name agent
characteristics and refer to them by name rather than by a list
index. The Agent class will be defined in a different file from
'model.py' so the program code going forwards will be in
multiple files.
</P>
<P>In your local code repository src directory create a new
directory called "abm4". Open Spyder and use 'save as' to save
your 'model.py' file from abm3 into the abm4 directory.
</P>
<h2 id="1">1. Define an Agent class</h2>
<P>Create a new file in the abm4 directory named
'agentframework.py', and add a class definition for an Agent
class in it as follows:
</P>
<pre><code class="language-python">
class Agent():
    pass
</code></pre><P>The keyword 'pass' ensures the code is syntactically correct
and will run.
</P>
<P>In 'model.py' reduce 'n_iterations' to 10, and add the following
import statement:
</P>
<pre><code class="language-python">
import agentframework as af</code></pre><P>Note that this imports the agentframework module as loaded from
'agentframework.py' which is to be referred to by 'af'.
</P>
<P>At the start of the '# Initialise agents' code block, add the
following:
</P>
<pre><code class="language-python">
a = af.Agent()
print("type(a)", type(a))
</code></pre><P>Run 'model.py' and examine the output. It should contain the
following line:
</P>
<pre>type(a) <class 'agentframework.Agent'></pre>
<P>This indicates that an instance of the class Agent as defined
in the agentframework module was successfully created.
</P>
<P>Add a constructor method to the Agent class that initialises 'x'
and 'y' variable attributes to be random integers in the range
[0, 99]. The code in 'agentframework.py' should be:
</P>
<pre><code class="language-python">
import random

class Agent:
    def __init__(self):
        self.x = random.randint(0, 99)
        self.y = random.randint(0, 99)
</code></pre><P>Note that the <a href="https://docs.python.org/3/library/random.html">random module</a> is imported as this is used in the Agent constructor '__init__'
method.
</P>
<P>In 'model.py', add a statement to print the agent that was
instantiated, and run the program again. Text along the lines
of the following should be in the output:
</P>
<pre>&lt;agentframework.Agent object at 0x00000249AEA21D88&gt;</pre>
<P>The last part of this will almost certainly be different to
'0x00000249AEA21D88' and if you run your program again, it will
likely be different again. Recall that this string is a memory
address identifying where the object is stored in the memory of
the computer.
</P>
<P>When printing an Agent instance, it would be better if something
more informative was output. The best way to do this is to
override the '__str__' method which comes from the 'type'
metaclass that all classes inherit from by default. Define the
method in the Agent class as follows:
</P>
<pre><code class="language-python">
def __str__(self):
   return self.__class__.__name__ + "(x=" + str(self.x) \
      + ", y=" + str(self.y) + ")"
</code></pre><P>Note that this returns a string which includes the name of the
class and details of the 'x' and 'y' variable attributes which
are transformed by the builtins module
<a href="https://docs.python.org/3/library/functions.html#func-str">str function</a> to be strings.</P>
<P>Run 'model.py' again and the print statement should result in
the following:
</P>
<pre>Agent(x=49, y=97)</pre>
<P>Change the '# Initialise agents' code block in 'model.py' to:
</P>
<pre><code class="language-python">
# Initialise agents
agents = []
for i in range(n_agents):
    # Create an agent
    agents.append(af.Agent())
    print(agents[i])
print(agents)
</code></pre><P>Run 'model.py' and you should get similar output to the
following (in the error report, the file paths will probably be
different, and the line numbers might be different):
</P>
<pre>Check this is equal to 5: 5.0
Agent(x=49, y=97)
Agent(x=53, y=5)
Agent(x=33, y=65)
Agent(x=62, y=51)
Agent(x=38, y=61)
Agent(x=45, y=74)
Agent(x=27, y=64)
Agent(x=17, y=36)
Agent(x=17, y=96)
Agent(x=12, y=79)
[&lt;agentframework.Agent object at 0x00000249B140C6C8&gt;, &lt;agentframework.Agent object at 0x00000249B14194C8&gt;, &lt;agentframework.Agent object at 0x00000249B1419148&gt;, &lt;agentframework.Agent object at 0x00000249B1419388&gt;, &lt;agentframework.Agent object at 0x00000249B14193C8&gt;, &lt;agentframework.Agent object at 0x00000249B1419448&gt;, &lt;agentframework.Agent object at 0x00000249B14191C8&gt;, &lt;agentframework.Agent object at 0x00000249B1419048&gt;, &lt;agentframework.Agent object at 0x00000249B1419488&gt;, &lt;agentframework.Agent object at 0x00000249B1419208&gt;]
Traceback (most recent call last):

  File "\abm4\model.py", line 95, in &lt;module&gt;
    print("Maximum distance between all the agents", get_max_distance())

  File "\abm4\model.py", line 81, in get_max_distance
    distance = get_distance(a[0], a[1], b[0], b[1])

TypeError: 'Agent' object is not subscriptable
</pre>
<P>The list 'agents' is initialised, but the print function does
not use the '__str__' method to get string representations when
printing the list.
</P>
<P>The <a href="https://docs.python.org/3/library/exceptions.html#TypeError">TypeError</a> is a consequence of the 'agents' list no longer containing
lists, but instantiated Agent objects, and some parts of the
code are still written as though each agent is a list and not an
instance of the Agent class.
</P>
<P>Add the following method to the Agent class to get the print
function to print string representations when printing the
agents list:
</P>
<pre><code class="language-python">
def __repr__(self):
    return str(self)
</code></pre><P>Like the '__str__' method, the '__repr__' method overrides from
the 'type' metaclass, (for details see:
<a href="https://docs.python.org/3/library/functions.html#repr">repr</a>.</P>
<P>To avoid raising the TypeError exception, it is necessary to
refer to the class attributes and not list items (as agents are
no longer lists, but are instances of the class Agent). So,
change the following line of code in the 'get_max_distance()'
function:
</P>
<pre><code class="language-python">
distance = get_distance(a[0], a[1], b[0], b[1])</code></pre><P><p>To be:</p></P>
<pre><code class="language-python">
distance = get_distance(a.x, a.y, b.x, by)</code></pre><P>Appreciate that this is easier to read and understand.</P>
<P>Everywhere else in the 'model.py' that was referring to a
coordinate from the agents list is to be changed similarly. Run
'model.py' to see where the next TypeError is raised.
</P>
<P>In the code change:</P>
<pre><code class="language-python">
agents[i][0]</code></pre><P>To:</P>
<pre><code class="language-python">
agents[i].x</code></pre><P>And change:</P>
<pre><code class="language-python">
agents[i][1]</code></pre><P>To:</P>
<pre><code class="language-python">
agents[i].y</code></pre><P>Make a further change in the code block that plots agents,
changing:
</P>
<pre><code class="language-python">
# Plot the coordinate with the largest x red
lx = max(agents, key=operator.itemgetter(0))
plt.scatter(lx[0], lx[1], color='red')
# Plot the coordinate with the smallest x blue
sx = min(agents, key=operator.itemgetter(0))
plt.scatter(sx[0], sx[1], color='blue')
# Plot the coordinate with the largest y yellow
ly = max(agents, key=operator.itemgetter(1))
plt.scatter(ly[0], ly[1], color='yellow')
# Plot the coordinate with the smallest y green
sy = min(agents, key=operator.itemgetter(1))
plt.scatter(sy[0], sy[1], color='green')
</code></pre><P>To:</P>
<pre><code class="language-python">
# Plot the coordinate with the largest x red
lx = max(agents, key=operator.attrgetter('x'))
plt.scatter(lx.x, lx.y, color='red')
# Plot the coordinate with the smallest x blue
sx = min(agents, key=operator.attrgetter('x'))
plt.scatter(sx.x, sx.y, color='blue')
# Plot the coordinate with the largest y yellow
ly = max(agents, key=operator.attrgetter('y'))
plt.scatter(ly.x, ly.y, color='yellow')
# Plot the coordinate with the smallest y green
sy = min(agents, key=operator.attrgetter('y'))
plt.scatter(sy.x, sy.y, color='green')
</code></pre><P>Study these changes. Your program should run without raising
exceptions and produces the same output as previously.
</P>
<P>Add and commit to your local git repository and assuming you are
using GitHub - push your changes to GitHub.
</P>
<h2 id="2">2. Separation of Concerns</h2>
<P>Define a method called 'move' in the Agent class as follows:</P>
<pre><code class="language-python">
def move(self, x_min, y_min, x_max, y_max):</code></pre><P>Cut the code that moves an individual agent from 'model.py' and
paste it into the body of the new 'move' method. Replace:
"agents[i]" with "self" in the method. Where the code was cut
from, add the following to call the move method:
</P>
<pre><code class="language-python">
agents[i].move(x_min, y_min, x_max, y_max)</code></pre><P>Note that in the Agent class, the 'move' method has a parameter
called 'self', but this is not a parameter that is passed in.
Normally when calling a function the number of parameters
matches, but for methods (functions in a class) there is this
additional parameter that is not passed in and that is the first
parameter.
</P>
<P>Run the program and it should produce the same results as
previously. The Agent class code now deals with the details of
how an agent moves, and 'model.py' actions when they do. This is
a reasonable separation of concerns.
</P>
<h2 id="3">3. Give each agent a unique name</h2>
<P>It is possible that two agents will be located at the same
coordinates, and it would be helpful to distinguish them.
</P>
<P>Add a <a href="https://peps.python.org/pep-0257/#what-is-a-docstring">docstring</a>and a parameter to the '__init__' constructor method of Agent
so that the method is as follows:
</P>
<pre><code class="language-python">
def __init__(self, i):
"""
The constructor method.

Parameters
----------
i : Integer
    To be unique to each instance.

Returns
-------
None.

"""
self.i = i
self.x = random.randint(0, 99)
self.y = random.randint(0, 99)
pass
</code></pre><P>Run 'model.py' and you should get the following error:</P>
<pre>Traceback (most recent call last):

File "\abm4\model.py", line 91, in &amp;module>
  agents.append(agentframework.Agent())

TypeError: __init__() missing 1 required positional argument:
'i'
</pre>
<P>The TypeError is indicating that an expected argument is
missing in the call that creates the Agent instance. Change
'model.py' to pass in the missing argument 'i'. Make sure the
positional arguments are in a correspodiong order in the method
call and in the method definition. Run the program again and
the TypeError should not be raised.
</P>
<P>Modify the Agent class '__str__' method so it additionally
returns the unique characteristic of each Agent 'i'.
</P>
<P>Add and commit to your local git repository and assuming you are
using GitHub - push your changes to GitHub.
</P>
</div>

<footer>
<div>
<p><a id="next" class="nav" href="../io/index.html">Next: IO</a></p>
</div>
<p>Date last modified: 2023-08-19.</p>
<p><a href="https://creativecommons.org/share-your-work/public-domain/cc0/">CC0 Licence</a></p>
</footer>
</body>
</html>
