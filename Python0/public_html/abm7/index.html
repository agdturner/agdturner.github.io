<!DOCTYPE html>
<HTML lang=en-GB>

<HEAD>

<TITLE>Agent Based Model Practical 7 Page</TITLE>
<!-- Styling -->
<!-- Some href attributes are to be set by scripts -->
<link id="css" rel="stylesheet" type="text/css" href="">
<script src="/scripts/style.js"></script>
<!-- For styling code -->
<script src="/tools/highlight/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
<link id="code_theme" rel="stylesheet" type="text/css" href="">
<link id="css1" rel="stylesheet" type="text/css" href="">
<link id="css2" rel="stylesheet" type="text/css" href="">

</HEAD>

<BODY>

<button id="style_button" onclick="swapStyle()"></button>

<DIV class="navbar">
<a id="home" class="nav" href="../home/index.html">Home</a> <a id="programming" class="nav" href="../programming/index.html">Programming</a> <a id="python" class="nav" href="../python/index.html">Python</a> <a id="variables" class="nav" href="../variables/index.html">Variables</a> <a id="github" class="nav" href="../github/index.html">GitHub</a> <a id="abm1" class="nav" href="../abm1/index.html">ABM1</a> <a id="containers" class="nav" href="../containers/index.html">Containers</a> <a id="branching" class="nav" href="../branching/index.html">Branching</a> <a id="loops" class="nav" href="../loops/index.html">Loops</a> <a id="abm2" class="nav" href="../abm2/index.html">ABM2</a> <a id="functions" class="nav" href="../functions/index.html">Functions</a> <a id="abm3" class="nav" href="../abm3/index.html">ABM3</a> <a id="classes" class="nav" href="../classes/index.html">Classes</a> <a id="abm4" class="nav" href="../abm4/index.html">ABM4</a> <a id="io" class="nav" href="../io/index.html">IO</a> <a id="abm5" class="nav" href="../abm5/index.html">ABM5</a> <a id="modules" class="nav" href="../modules/index.html">Modules</a> <a id="abm6" class="nav" href="../abm6/index.html">ABM6</a> <a id="exceptions" class="nav" href="../exceptions/index.html">Exceptions</a> <a id="abm7" class="nav" href="../abm7/index.html">ABM7</a> <a id="gui" class="nav" href="../gui/index.html">GUI</a> <a id="abm8" class="nav" href="../abm8/index.html">ABM8</a> <a id="web" class="nav" href="../web/index.html">Web</a> <a id="abm9" class="nav" href="../abm9/index.html">ABM9</a> <a id="testing" class="nav" href="../testing/index.html">Testing</a> <a id="index" class="nav" href="../index/index.html">Index</a> <a id="references" class="nav" href="../references/index.html">References</a>
</DIV>

<H1>Agent Based Model Practical 7</H1>

<DIV>
<H2>Contents</H2>
<UL>
 <LI><A href="#1">1. Introduction and Preparation</A></LI>
 <LI><A href="#2">2. Animation</A></LI>
 <LI><A href="#3">3. Code and Model Review</A></LI>
</UL>
</DIV>

<DIV>
<H2 id="1">1. Introduction and Preparation</H2>
<P>In this practical
<a href="https://matplotlib.org/stable/api/_as_gen/matplotlib.animation.FuncAnimation.html">
matplotlib.animation.FuncAnimation</a>
will be used to animate the model in a separate window. Some
stopping conditions will be added to halt the model and exit.
</P>
<P>In your local code repository 'src' directory duplicate your
'abm6' directory and name it 'abm7'.
</P>
</DIV>

<DIV>
<H2 id="2">2. Animation</H2>
<P>Open the new 'model.py' file from the 'abm7' directory in
Spyder.
</P>
<P>Add the following import statement:</P>
<PRE><CODE class="language-python">import matplotlib.animation as anim</CODE></PRE>

<P>After initialising agents add the following code block:</P>
<PRE><CODE class="language-python"># Animate
# Initialise fig and carry_on
fig = matplotlib.pyplot.figure(figsize=(7, 7))
ax = fig.add_axes([0, 0, 1, 1])
carry_on = True
data_written = False
animation = anim.FuncAnimation(fig, update, init_func=plot, frames=gen_function, repeat=False)
</CODE></PRE>

<P>Define a new function called 'plot' to contain the 'Plot agents'
code. Add a line to clear fig at the start of the function and
specify 'ite' as a global variable before it is used:
</P>
<PRE><CODE class="language-python">fig.clear()
plt.ylim(y_min, y_max)
plt.xlim(x_min, x_max)
plt.imshow(environment)
for i in range(n_agents):
    plt.scatter(agents[i].x, agents[i].y, color='black')
# Plot the coordinate with the largest x red
lx = max(agents, key=operator.attrgetter('x'))
plt.scatter(lx.x, lx.y, color='red')
# Plot the coordinate with the smallest x blue
sx = min(agents, key=operator.attrgetter('x'))
plt.scatter(sx.x, sx.y, color='blue')
# Plot the coordinate with the largest y yellow
ly = max(agents, key=operator.attrgetter('y'))
plt.scatter(ly.x, ly.y, color='yellow')
# Plot the coordinate with the smallest y green
sy = min(agents, key=operator.attrgetter('y'))
plt.scatter(sy.x, sy.y, color='green')
global ite
filename = '../../data/output/images/image' + str(ite) + '.png'
plt.savefig(filename)
images.append(imageio.imread(filename))
plt.show()
</CODE></PRE>

<P>Change the 'main simulation loop' code block into a function
called 'update' that has a parameter called 'frames'. At the end
of this call the 'plot' function. Specify 'carry_on' as a global
variable and add a random stopping condition as follows:
</P>
<PRE><CODE class="language-python">def update(frames):
    # Model loop
    #for ite in range(1, n_iterations + 1):
    print("Iteration", frames)
    # Move agents
    print("Move and eat")
    for i in range(n_agents):
        agents[i].move(x_min, y_min, x_max, y_max)
        agents[i].eat()
        #print(agents[i])
    # Share store
    print("Share")
    # Distribute shares
    for i in range(n_agents):
        agents[i].share(neighbourhood)
    # Add store_shares to store and set store_shares back to zero
    for i in range(n_agents):
        #print(agents[i])
        agents[i].store = agents[i].store_shares
        agents[i].store_shares = 0
    #print(agents)
    # Print the maximum distance between all the agents
    print("Maximum distance between all the agents", get_max_distance())
    # Print the total amount of resource
    sum_as = sum_agent_stores()
    print("sum_agent_stores", sum_as)
    sum_e = sum_environment()
    print("sum_environment", sum_e)
    print("total resource", (sum_as + sum_e))

    # Stopping condition
    global carry_on
    # Random
    if random.random() < 0.1:
        #if sum_as / n_agents > 80:
        carry_on = False
        print("stopping condition")

    # Plot
    plot()
</CODE></PRE>

<P>Define a function called 'gen_function' as follows:</P>
<PRE><CODE class="language-python">def gen_function():
    global ite
    global carry_on
    while (ite <= n_iterations) & (carry_on) :
        yield ite # Returns control and waits next call.
        ite = ite + 1
    global data_written
    if data_written == False:
        # Write data
        print("write data")
        io.write_data('../../data/output/out.txt', environment)
        imageio.mimsave('../../data/output/out.gif', images, fps=3)
        data_written = True
</CODE></PRE>

<P>Before running the code, issue the following magic command in
the Spyder console so that rather than the plot being directed
to the plots pane (where") animation does not work), it is
 directed to a pop-up window:
</P>
<PRE>%matplotlib qt</PRE><P>If you want to revert this change so that plots are added to the
 plot plane again issue the following magic command:
</P>
<PRE>%matplotlib inline</PRE><P>The keyword '<a href="../index/index.html#Python yield">yield</a>' is used to pass the value of the variable 'ite' back from
'gen_function' whilst continuing to run the while loop. The
'# Write data' code block is included in 'gen_function' and runs
 only once after the model has stopped.
</P>
<P>Add and commit to your local git repository and assuming you are
using GitHub - push your changes to GitHub.
</P>
</DIV>

<DIV>
<H2 id="3">3. Code and Model Review</H2>
<P>Most of your code should now be in functions and organised into
modules.
</P>
<P>The model simulation runs in a loop until some condition is
reached, or until a predefined number of iterations
'n_iterations' is reached.
</P>
<P>As yet, the model cannot be re-started. Some data is written to
file that could be used to restart the model, but this is
incomplete/insufficient. The ability to be able to stop and
restart a model can be useful. This is known as 'check
pointing'. It is often good to be able to run a simulation model
for 'n' iterations and then run for a further 'm' iterations,
and for this to produce the same results as for a run of 'm + n'
iterations. The 'random.getstate()' and 'random.setstate(state)'
methods can be used to store the state of 'random' to get this
to work.
</P>
<P>The simple agents in the model are not learning or adapting
their behaviour based on interaction or the state of the
environment. The model is mostly random, so observing complex,
adaptive/emergent behaviour from this model should not be
expected.
</P>
<P>Whilst the model has been framed as an ecological model, the
agents could represent other things, they don't necessarily have
to communicate by sharing resources, they could share something
else, and they don't have to 'eat' the environment.
</P>
<P>Some ideas for a more realistic ecological model are:</P>
<UL>
<LI>To have less resource that can be eaten by the agents, and
model this resource as vegetation that grows.
</LI>
<LI>Make movement cost some amount of store.</LI>
<LI>Have those agents that are successful at finding resources
duplicate and those unsuccessful die.
</LI>
<LI>Include predator agents that hunt/eat the other agents as prey.
</LI>
</UL>
</DIV>

<DIV>

<div>
<p><a id="next" class="nav" href="../gui/index.html">Next: GUI</a></p>
</div>
<P>Date last modified: 2026-01-12</P>

<P><a href="https://creativecommons.org/share-your-work/public-domain/cc0/">CC0 Licence</a></P>

</DIV>

</BODY>

</HTML>

