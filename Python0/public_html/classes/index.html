<!DOCTYPE html>
<HTML lang=en-GB>

<HEAD>

<TITLE>Classes Page</TITLE>
<!-- Styling -->
<!-- Some href attributes are changed by scripts -->
<link id="css" rel="stylesheet" type="text/css" href="/tools/highlight/styles/default.min.css">
<script src="/scripts/style.js"></script>
<!-- For styling code -->
<script src="/tools/highlight/highlight.min.js"></script>
<script>hljs.highlightAll();</script>
<link id="code_theme" rel="stylesheet" type="text/css" href="/css/style.css">
<link id="css1" rel="stylesheet" type="text/css" href="/tools/highlight/styles/github-dark.min.css">
<link id="css2" rel="stylesheet" type="text/css" href="/css/style_dark.css">

</HEAD>

<BODY>

<button id="style_button" onclick="swapStyle()"></button>

<DIV id="navigation" class="navbar"><a id="home" class="nav" href="../home/index.html">Home</a> <a id="programming" class="nav" href="../programming/index.html">Programming</a> <a id="python" class="nav" href="../python/index.html">Python</a> <a id="variables" class="nav" href="../variables/index.html">Variables</a> <a id="github" class="nav" href="../github/index.html">GitHub</a> <a id="abm1" class="nav" href="../abm1/index.html">ABM1</a> <a id="containers" class="nav" href="../containers/index.html">Containers</a> <a id="branching" class="nav" href="../branching/index.html">Branching</a> <a id="loops" class="nav" href="../loops/index.html">Loops</a> <a id="abm2" class="nav" href="../abm2/index.html">ABM2</a> <a id="functions" class="nav" href="../functions/index.html">Functions</a> <a id="abm3" class="nav" href="../abm3/index.html">ABM3</a> <a id="classes" class="nav" href="../classes/index.html">Classes</a> <a id="abm4" class="nav" href="../abm4/index.html">ABM4</a> <a id="io" class="nav" href="../io/index.html">IO</a> <a id="abm5" class="nav" href="../abm5/index.html">ABM5</a> <a id="modules" class="nav" href="../modules/index.html">Modules</a> <a id="abm6" class="nav" href="../abm6/index.html">ABM6</a> <a id="exceptions" class="nav" href="../exceptions/index.html">Exceptions</a> <a id="abm7" class="nav" href="../abm7/index.html">ABM7</a> <a id="gui" class="nav" href="../gui/index.html">GUI</a> <a id="abm8" class="nav" href="../abm8/index.html">ABM8</a> <a id="web" class="nav" href="../web/index.html">Web</a> <a id="abm9" class="nav" href="../abm9/index.html">ABM9</a> <a id="testing" class="nav" href="../testing/index.html">Testing</a> <a id="conclusion" class="nav" href="../conclusion/index.html">Conclusion</a> <a id="index" class="nav" href="../index/index.html">Index</a> <a id="references" class="nav" href="../references/index.html">References</a>
</DIV>

<H1>Classes</H1>

<DIV>
<H2>Contents</H2>
<UL>
 <LI><A href="#1">1. Introduction</A></LI>
 <LI><A href="#2">2. Class Definitions, Constructors, Attributes and Methods</A></LI>
 <LI><A href="#3">3. Inheritance</A></LI>
 <LI><A href="#4">4. Access Control</A></LI>
 <LI><A href="#5">5. Customisation</A></LI>
 <LI><A href="#6">6. Further learning</A></LI>
</UL>
</DIV>


<DIV>
<H2 id="1">1. Introduction</H2>
<P>Classes are templates for making objects. Objects are instances
of the 'class' that defines them. There can be many objects
that are instances of a class, like there are many individual
people that are humans. Classes define the attributes and
functionality of objects. In Python, the functions defined in a
class are known as 'methods' and the 'type' of an object is the
class that defines it.
</P>
<P>Python class definitions can be embedded throughout programs,
but it is considered good practice to organise classes in
'modules'.
</P>
<P>Modules are source code files, the name of the module is given
by the filename which should be a short word all in lowercase.
Modules are commonly stored in a directory alongside the main
script that is run. If they are simply placed in the same
directory as the script that is run, then there can be name
collisions with modules in the standard library and this is best
avoided. It is good to organise code into modules as this makes
it more reusable, and having lots of code in one file becomes
cumbersome. (Details on modules is provided after the next ABM
practical.)
</P>
<P>The name of a class should start with a capital letter and be
in 'CamelCase' (with no spaces and mostly in lower case except
for capitalised first letters for each word).
</P>
</DIV>


<DIV>
<H2 id="2">2. Class Definitions, Constructors, Attributes and Methods</H2>
<P>A class is defined using the keyword 'class' followed by the
name of the class, parentheses, and a colon, for example:
</P>
<PRE><CODE class="language-python">class Agent():</CODE></PRE>


Class names separated by commas can be added in the parentheses
to declare parent classes that the class inherits from. Class
inheritence is detailed further in <a href="#3">Section 3</a>.
<P>As mentioned, in Python, functions inside classes are called
'methods'. A class in Python has one and only one constructor
method named '__init__'. The constuctor method is used to
initialise attributes of an instance when it is constructed. A
default parameter, by convention called 'self' is always first
parameter. This 'self' parameter effectively refers to a generic
instance of the class and is used within the class to define and
refer to attributes and methods of the class. For example,
instances of the following 'Agent' class are instantiated with
'x' and 'y' attribute variables that are initially set to be
zero:
</P>
<PRE><CODE class="language-python">class Agent():
    def __init__(self):
        self.x = 0
        self.y = 0
</CODE></PRE>


<P>Suppose this class was in a file named 'agentframework.py' -
and so in a module named 'agentframework', it could be
instantiated from a script in the same directory as
'agentframework.py' as follows:
</P>
<PRE><CODE class="language-python">import agentframework
a = agentframework.Agent()
</CODE></PRE>


<P>And the 'x' and 'y' aatribute variables of 'a' - the instance
of the class could then be accessed using the dot operator '.'
as follows:
</P>
<PRE><CODE class="language-python">print(a.x) # <-- Prints the value of a.x
print(a.y) # <-- Prints the value of a.y
a.x = 3 # <-- Sets the values of a.x to be 3
a.y = a.y + 1 # <-- Increases the value of a.y by 1
</CODE></PRE>


<P>A class constructor method may accept multiple arguments. For
example, the initial values for 'x' and 'y' could be passed in
as follows:
</P>
<PRE><CODE class="language-python">class Agent():
    def __init__(self, x, y):
        self.x = x
        self.y = y
</CODE></PRE>


<P>When instantiating an instance of this Agent class, it is
necessary to pass in two argument as the constructor method does
not set defaults of these values. The following code will
instantiate an Agent object using the latest class definition
above:
</P>
<PRE><CODE class="language-python">import agents
a = agents.Agent(0, 0)
</CODE></PRE>


<P>The parameters 'x' and 'y' do not have to have names
corresponding to the attributes, and they can be given default
values making it optional as to whether these are supplied, by
changing the constructor method as follows:
</P>
<PRE><CODE class="language-python">class Agent():
    def __init__(self, x = 0, y = 0):
        self.x = x
        self.y = y
</CODE></PRE>


</DIV>


<DIV>
<H2 id="3">3. Inheritance</H2>
<P>In Python, all classes inherit (attributes and methods) from the
'type' metaclass. A 'metaclass' can be thought of as a factory
for producing classes.
</P>
<P>The classes from which a class inherits are known as 'super
classes', and the classes that inherit from another class are
known as 'subclasses'.
</P>
<P>Inheritance is heirarchical and allows for things in common to
multiple classes to be stored in a super class avoiding having
to define attributes and methods repeatedly in subclasses. Those
attributes and methods in a superclass are accessible directly
from subclasses.
</P>
<P>Methods can be 'overridden' by defining a method with the same
name as the superclass method. The function super() can be used,
to access an overriden method. In this way an overridden method
can access the superclass method that it is overriding as shown
in the example below.
</P>
<P>Python supports 'multiple inheritance' where a subclass may
inherit from multiple superclasses. To do this, the classes
being inherited from are specified in the class definition, each
separated by a comma.
</P>
<P>The following defines 'Goat' and 'Wolf' as classes that inherit
from the 'Agent' class:
</P>
<PRE><CODE class="language-python">class Agent():
    def __init__(self, x, y):
        self.x = x
        self.y = y

class Goat(Agent):
    def __init__(self, x, y):
        super().__init__(x, y)
        self.hungry = True

class Wolf(Agent):
    def __init__(self, x, y, pack):
        super().__init__(x, y)
        self.pack = pack
</CODE></PRE>


<P>The constructor methods of the Goat and Wolf classes call the
superclass constructor method. Each instance of Goat would be
instantiated with the attribute 'self.hungry' equal to 'True'.
Each instance of Wolf is given a parameter called 'pack' when
constructed. This is a variable which is assigned to the
attribute with the same name. In this example, 'pack' could be a
identifier or a list or something else.
</P>
<P>Inheritance allows for a class (call it 'A') to be extended to
create different subclasses, and a further class to be defined
as the subclass of multiple of the subclasses of A. In such a
case, there is an order in the way inheritence works and how
methods get overridden. For more details of this see:
<a href="https://docs.python.org/3/tutorial/classes.html#multiple-inheritance">
The Python Tutorial on Classes Section on Multiple Inheritance</a>.
</P>
</DIV>


<DIV>
<H2 id="4">4. Access Control</H2>
<P>Python does not have an direct way to declare the access level
or control access to variables or functions/methods as is common
in other languages.
</P>
<P>Instead there is a naming convention which is that variables
that have a name starting with an underscore and functions
starting with a double underscore are not to be accessed
directly from outside the class or module.
</P>
<P>The function property() can be used with a specifically named
get method to provide indirect access to a object attribute.
This can optionally allow for setting the attribute value and
deleting the attribute too. In the following example the
function property() is set up to pass, modify and delete the
attribute _x:
</P>
<PRE><CODE class="language-python">class Agent():
    def __init__(self, ax, ay):
        self._x = ax
        self._y = ay

    def getx(self):
        return self._x

    def setx(self, value):
        self._x = value

    def delx(self):
        del self._x

    x = property(getx, setx, delx, "I'm the 'x' property.")
</CODE></PRE>


<P>This could be used from another module as follows:</P>
<PRE><CODE class="language-python">import agents:
a = agent.Agent(0, 0):
a.x = 3
print(a.x) # <-- Prints 3
</CODE></PRE>


<P>So, rather than access the attribute _x directly, this is done
via a function which is aliased as x.
</P>
<P>Decorators can alternatively be used to achieve the same thing
as follows:
</P>
<PRE><CODE class="language-python">class Agent():
    def __init__(self, ax, ay):
        self._x = ax
        self._y = ay

    @property
    def x(self):
        """I'm the 'x' property."""
        return self._x

    @x.setter
    def x(self, value):
        self._x = value

    @x.deleter
    def x(self):
        del self._x
</CODE></PRE>


Details of this are provided in:
<a href="https://docs.python.org/3/library/functions.html#property">
The Python Library Documentation Chapter on Functions Section on Property</a>.
</DIV>


<DIV>
<H2 id="5">5. Customisation</H2>
<P>By default, when printing an object using the <a href="../index/index.html#Python_print">print</a> function, the memory address of the object is printed, but
rarely is this useful. The '__str__' method can be overriden to
provide a more useful string representation of an object, for
example:
</P>
<PRE><CODE class="language-python">class Agent():
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __str__(self):
        return "x=" + self.str(x) + ", y=" + self.str(y)

class Goat(Agent):
    def __init__(self, x, y):
        super().__init__(x, y)
        self.hungry = True

    def __str__(self):
        return super().__str__() + ", hungry=" + self.str(hungry)
</CODE></PRE>


<P>More details on customisation can be found in
<a href="https://docs.python.org/3/reference/datamodel.html#basic-customization">
The Python 3 Language Reference Data Model Chapter Section on Basic Customization</a>.
</P>
</DIV>


<DIV>
<H2 id="6">6. Further learning</H2>
<P>For a more in depth consideration of classes, see:
<a href="https://docs.python.org/3/tutorial/classes.html">
The Python Tutorial on Classes</a>.
</P>
</DIV>

<DIV>

<P><a id="next" class="nav" href="../abm4/index.html">Next: ABM4</a></P>

<P>Date last modified: 2026-01-17</P>

<P><a href="https://creativecommons.org/share-your-work/public-domain/cc0/">CC0 Licence</a></P>

</DIV>

</BODY>

</HTML>

